package main

import "fmt"

// Quicksort требует двух вещей - свап и партишн
// Определим партишн

func partition(arr []int, l int, h int) int {
	pivot := arr[l]
	i, j := l, h

	// Общая идея здесь - найти такую позицию, где все значения слева - меньше, а справа - больше
	// На начальном этапе эти разные числа могут быть неупорядоченными
	// Тем не менее, рекурсия позволяет упорядочить элементы справа и слева от пивота

	for {
		for arr[i] < pivot { // Пока значения меньше, ищем положение, чтобы слева были значения меньше пивота
			i++
		}

		for arr[j] > pivot { // Пока значения больше, ищем крайний элемент, который больше пивота
			j--
		}

		if i >= j { // Если i >= j, то мы такие элементы не нашли
			break
		}

		if arr[i] == arr[j] { // Обрабатываем дубликаты
			i++
			j--
		} else {
			arr[i], arr[j] = arr[j], arr[i] // А вот он и свап
		}
	}

	return j
}


func quicksort(arr []int, l int, h int) {
	if l < h {
		j := partition(arr, l, h) // Берем началиный партишн
		quicksort(arr, l, j-1) // Тут рекурсивно левую сторону сортируем
		quicksort(arr, j+1, h) // Тут рекурсивно правую сторону сортируем
	}
}

func main() {
	arr := []int{5, 4, 3, 2, 1, -20, -30, -20, 1, 1, -1}
	quicksort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}
