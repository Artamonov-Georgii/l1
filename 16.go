package main

import "fmt"

// partition() отвечает за разделение переданного ей массива на две части. Она выбирает первый элемент массива
// в качестве опорного, а затем перемещает все элементы, которые меньше опорного, влево от него, а все элементы,
// которые больше опорного, вправо от него. Функция возвращает индекс опорного элемента после окончания работы
func partition(arr []int, l int, h int) int {
	// Выбираем первый элемент массива в качестве опорного
	pivot := arr[l]
	i, j := l, h

	// Начинаем перемещать элементы таким образом, чтобы значения слева от опорного были меньше опорного,
	// а справа - больше опорного. Это обеспечивает разделение на две части
	for {
		// Находим первый элемент слева от опорного, который больше него
		for arr[i] < pivot {
			i++
		}

		// Находим первый элемент справа от опорного, который меньше него
		for arr[j] > pivot {
			j--
		}

		// Если i >= j, то это значит, что мы закончили работу
		if i >= j {
			break
		}

		// Если есть дубликаты, то пропускаем их и продолжаем поиск
		if arr[i] == arr[j] {
			i++
			j--
		} else {
			// Если мы нашли два элемента, которые находятся в неправильных частях, то меняем их местами
			arr[i], arr[j] = arr[j], arr[i]
		}
	}

	// Возвращаем индекс опорного элемента
	return j
}

// quicksort() - это рекурсивная функция сортировки, которая сортирует переданный массив путем вызова
// partition() и рекурсивного применения этой же функции к левой и правой частям массива, полученным в результате вызова partition().
func quicksort(arr []int, l int, h int) {
	// Базовый случай - массив имеет длину 1
	if l < h {
		// Вызываем partition(), чтобы разделить массив на две части и получить индекс опорного элемента
		j := partition(arr, l, h)

		// Рекурсивно вызываем quicksort() для левой части массива
		quicksort(arr, l, j-1)

		// Рекурсивно вызываем quicksort() для правой части массива
		quicksort(arr, j+1, h)
	}
}

func main() {
	arr := []int{5, 4, 3, 2, 1, -20, -30, -20, 1, 1, -1}
	quicksort(arr, 0, len(arr)-1)
	fmt.Println(arr)
}
